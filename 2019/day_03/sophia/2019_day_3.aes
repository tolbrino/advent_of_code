include "List.aes"
include "Pair.aes"

contract AdventOfCode2019Day03 =

  type plan = map(int * int, int * map(int, int * int))
  type input = list(string)
  type position = int * int
  type wire = list(char * int)
  type tagged_wire = int * wire

  entrypoint test() : bool =
    let input1 = ["R75,D30,R83,U83,L12,D49,R71,U7,L72", "U62,R66,U55,R34,D71,R55,D58,R83"]
    let input2 = ["R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51", "U98,R91,D20,R16,D67,R40,U7,R15,U6,R7"]
    require(159 == result(solve_1(prepare(input1))), "test 1 failed")
    require(135 == result(solve_1(prepare(input2))), "test 2 failed")
    //assert(610 == result(solve_2(["R75,D30,R83,U83,L12,D49,R71,U7,L72",
     //         "U62,R66,U55,R34,D71,R55,D58,R83"]))),
    //assert(410 = result(solve_2(["R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51",
     //         "U98,R91,D20,R16,D67,R40,U7,R15,U6,R7"]))),
    true

  function result(points : list(int)) : int =
    switch(List.first(points))
      None =>
        0
      Some(n) =>
        n

  function prepare(wires : list(string)) : list(tagged_wire) =
    let wires' = List.map((wire) =>
      List.foldl((acc, w) =>
        switch(acc)
          (acc', d, l) =>
            switch(w)
              [] =>
                ((d, Bytes.to_int(l)) :: acc', "", [])
              ',' =>
                ((d, Bytes.to_int(l)) :: acc', "", [])
              c =>
                switch(d)
                  "" =>
                    ((c, l), acc')
                  _ =>
                    ((d, l ++ [c]), acc'), (("", []), []), wire), wires)
    List.zip(List.from_to(1, List.length(wires')), wires')

  function solve_1(wires : list(tagged_wire)) : list(int) =
    let plan = run_wires(wires, {})
    let points = Map.to_list(plan)
    let points' = List.foldl((acc, p) =>
      switch(p)
        ((pos_x, pos_y), (n, _)) =>
          if (n > 1)
            let l = abs(pos_x) + abs(pos_y)
            l :: acc
          else
            acc, [], points)
    List.sort((a, b) => a < b, points')

  function run_wires(wires : list(tagged_wire), plan : plan) : plan =
    List.foldl((acc, w) =>
      switch(w)
        (wire_id, wire) =>
          run_wire(wire_id, wire, (0, 0), 0, acc), plan, wires)

  function run_wire(wire_id : int, wire : wire, pos : position, steps : int, plan : plan) : plan =
    switch(wire)
      [] =>
        plan
      (d, l) :: rest =>
        switch (step_wire(d, l, pos, steps, wire_id, plan))
          (pos1, plan1, steps1) =>
            run_wire(wire_id, rest, pos1, steps1, plan1)

  function step_wire(dir : char, len : int, pos : position, steps : int, wire_id : int, plan : plan) =
    let pos' = update_position(pos, dir, len)
    let plan' = List.foldl((acc, n) =>
      let pos_n = update_position(pos, dir, 1)
      switch (acc[pos_n = (0, {})])
        (count, steps_record) =>
          let acc_entry = switch(Map.lookup(wire_id, steps_record))
            None =>
              (count+1, steps_record{[wire_id] = steps+1})
            Some(_) =>
              (count, steps_record)
          acc{[pos_n] = acc_entry}, plan, List.from_to(1, len))
    (pos', plan', steps+len)

  function update_position(pos : position, dir : char, len : int) : position =
    switch (pos)
      (pos_x, pos_y) =>
        switch(dir)
          'U' =>
            (pos_x, pos_y + len)
          'D' =>
            (pos_x, pos_y - len)
          'L' =>
            (pos_x - len, pos_y)
          'R' =>
            (pos_x + len, pos_y)

  function abs(i : int) : int =
    if (i < 0) i * (-1)
    else       i
