include "List.aes"
include "Pair.aes"

contract AdventOfCode2019Day03 =

  type plan = map(int * int, int * map(int * int))
  type input = list(string)
  type result = int
  type position = int * int

  entrypoint test() : bool ->
    assert(159 == result(solve_1(["R75,D30,R83,U83,L12,D49,R71,U7,L72",
              "U62,R66,U55,R34,D71,R55,D58,R83"]))),
    assert(135 == result(solve_1(["R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51",
              "U98,R91,D20,R16,D67,R40,U7,R15,U6,R7"]))),
    assert(610 == result(solve_2(["R75,D30,R83,U83,L12,D49,R71,U7,L72",
              "U62,R66,U55,R34,D71,R55,D58,R83"]))),
    assert(410 = result(solve_2(["R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51",
              "U98,R91,D20,R16,D67,R40,U7,R15,U6,R7"]))),
    true.

  function result(program : map(int, int)) : int =
    program[0]

  function solve_1(wires : list(string)) : list(int) =
    let plan = run_wire(wires, {})

  function run_wires(wires : list((int, string)), plan : plan) : plan =
                                                                 List.foldl((acc, (wire_id, wire)) =>
      run_wire(wire_id, wire, (0, 0), "", "", 0, acc)
      , plan, wires)

  function run_wire(wire_id : int, wire : string, pos : position, dir : string, len : string, steps : int, plan : plan) : plan =
    switch(wire)
      "" =>
        let (_, plan1, _) = step_wire(dir, len, pos, steps, wire_id, plan)
        plan1
      ',' :: rest =>
        let (pos1, plan1, step1) = step_wire(dir, len, pos, steps, wire_id, plan)
        run_wire(rest, pos1, "", "", steps1, plan1)
      c :: rest =>
        switch(dir)
          "" =>
            run_wire(wire_id, rest, pos, c, len, steps, plan)
          _ =>
            run_wire(wire_id, rest, pos, dir, len ++ [c], steps, plan)

  function step_wire(dir : string, len : string, pos : position, steps : int, wire_id : int, plan : plan) =
    let len1 = Bytes.to_int(len)
    let (pos_x, pos_y) = pos
    let pos' = update_pos(pos, dir, len1)
    let plan' = List.foldl((acc, n) =>
      let pos_n = update_pos(pos, dir, 1)
      let steps_n = steps + 1
      let (count, steps_record) = acc[pos_n = (0, {})]
lkjj
      let acc_entry = switch(steps_record[wire_id])
        None =>
          (count + 1, steps_record{[wire_id] = steps_n})
        Some(_) =>
          (count, steps_record)
      acc{[pos_n] = acc_entry}
      , plan, List.from_to(1, len1))
    (pos', plan', steps + len1)

  function update_position(pos : position, dir : string, len : int) : pos =
    let (pos_x, pos_y) = pos
    switch(dir)
      "U" =>
        (pos_x, pos_y + len)
      "D" =>
        (pos_x, pos_y - len)
      "L" =>
        (pos_x - len, pos_y)
      "R" =>
        (pos_x + len, pos_y)
